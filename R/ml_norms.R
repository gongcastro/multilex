#### ml_norms: Compute item norms ##############################################

#' Generate item-level norms for age, sex, language profile and item dominance
#' @importFrom googlesheets4 gs4_has_token
#' @importFrom dplyr left_join
#' @importFrom dplyr mutate
#' @importFrom dplyr select
#' @importFrom dplyr filter
#' @importFrom dplyr group_by_at
#' @importFrom dplyr summarise
#' @importFrom dplyr rowwise
#' @importFrom dplyr arrange
#' @importFrom tidyr pivot_longer
#' @importFrom tidyr drop_na
#' @export ml_norms
#' @param responses Responses data frame, as generated by \code{ml_responses}. If NULL (default), \code{ml_responses} is run.
#' @param participants Participants data frame, as generated by \code{ml_participants}. If NULL (default), \code{ml_participants} is run.
#' @param norms_language Language to compute vocabulary norms for: "catalan" and/or "spanish"
#' @param norms_type Vocabulary type to compute norms for: "understands", "produces"
#' @param norms_age Age range of participants to compute norms for. It takes a numeric vector of length two (min-max).
#' @param norms_lp Language profile of participants to compute norms for: "Bilingual", Monolingual", "Other"
#' @param norms_sex Sex of participants to compute norms for: "Female", "Male". Both included by default.
#' @param norms_category Semantic/functional category to include items from
#' @param conf Confidence level of confidence intervals. Defaults to 0.95.

#' @return A dataset with each participant's comprehensive and/or vocabulary size in each language
#' @examples
#' vocabulary <- ml_norms()
#'

ml_norms <- function(
  participants = NULL,
  responses = NULL,
  logs = NULL,
  google_email = NULL,
  norms_item = NULL,
  norms_language = c("Catalan", "Spanish"),
  norms_type = c("understands", "produces"),
  norms_age = c(0, 100),
  norms_lp = c("Bilingual", "Monolingual", "Other"),
  norms_sex = c("Female", "Male"),
  norms_category = NULL,
  conf = 0.95
) {
  if (!gs4_has_token()){
    ml_connect()
  }

  if (is.null(logs)) {
    if (is.null(responses)) {
      if (is.null(participants)){
        participants <- ml_participants()
      }
      responses <- ml_responses(participants = participants)
    }
    logs <- ml_logs(participants = participants, responses = responses)
  }

  group_vars <- c("te", "item", "language", "age_bin", "type", "lp", "item_dominance", "ipa", "label")

  if (is.null(norms_item)) norms_item <- unique(responses$item)
  if (is.null(norms_category)) norms_category <- unique(pool$category)

  norms <- responses %>%
    left_join(select(logs, id, time, lp), c("id", "time")) %>%
    mutate(
      understands = response %in% c(2, 3),
      produces = response %in% 3,
    ) %>%
    select(id, age, sex, lp, dominance, item, understands, produces) %>%
    pivot_longer(
      c(understands, produces),
      names_to = "type",
      values_to = "response") %>%
    mutate(age_bin = 2*as.numeric(
      cut(age, seq(0, 100, by = 2), labels = FALSE))) %>%
    left_join(
      select(pool, te, item, language, cognate, label, ipa, frequency_zipf, category),
              by = "item"
      ) %>%
    filter(
      item %in% norms_item,
      language %in% norms_language,
      type %in% norms_type,
      category %in% norms_category,
      between(age, norms_age[1], norms_age[2])
    ) %>%
    mutate(
      item_dominance = case_when(
      language==dominance ~ "L1",
      language!=dominance ~ "L2"
    )) %>%
    drop_na(response) %>%
    group_by_at(group_vars) %>%
    summarise(
      yes = sum(response, na.rm = TRUE),
      n = sum(!is.na(response), na.rm = TRUE),
      .groups = "drop"
    ) %>%
    rowwise() %>%
    mutate(
      proportion = prop_adj(yes, n),
      se = prop_adj_se(yes, n),
      ci_lower = prop_adj_ci(yes, n, .width = conf)[1],
      ci_upper = prop_adj_ci(yes, n, .width = conf)[2]
    ) %>%
    ungroup() %>%
    filter(type %in% norms_type) %>%
    arrange(te, item, language, lp, item_dominance, type, age_bin, proportion, yes, n, se, ci_lower, ci_upper)

  return(norms)

}
