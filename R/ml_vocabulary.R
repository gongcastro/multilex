#### ml_vocabulary: Compute vocabulary sizes ###################################

#' Generate participant information and progress for each response
#' @import dplyr
#' @importFrom tidyr pivot_longer
#' @importFrom tidyr drop_na
#' @importFrom janitor clean_names
#' @export ml_vocabulary
#' @param responses Responses data frame, as generated by \code{ml_responses}. If NULL (default), \code{ml_responses} is run.
#' @param participants Participants data frame, as generated by \code{ml_participants}. If NULL (default), \code{ml_participants} is run.
#' @param by A character vector that takes the name of the variable(s) to group data into. Vocabulary metrics will be calculated by aggregating responses within the groups that result from the combination of crossing of the variables provided in \code{by}. This variables can refer to item properties (see \code{pool}, e.g., "category") or to participant properties (see \code{ml_logs()}, e.g., "dominance").
#' @param scale A character vector that takes the value "counts" and/or "proportions". If "counts" (default) vocabulary metrics are reported as counts (number of words). If "proportions", vocabulary metrics are calculated as proportions?
#' @return A dataset with each participant's comprehensive and/or vocabulary size in each language
#' @examples
#' vocabulary <- ml_vocabulary()
#'

ml_vocabulary <- function(
  participants = NULL,
  responses = NULL,
  by = NULL,
  scale = "count"
) {

  ml_connect() # get credentials to Google and formr

  if (is.null(responses)) {
    if (is.null(participants)){
      participants <- ml_participants()
    }
    responses <- ml_responses(participants = participants)
  }

  logs <- ml_logs(participants, responses) # get logs

  vocab_base <- responses %>%
    mutate(
      understands = ifelse(is.na(response), NA, response %in% c(2, 3)),
      produces = ifelse(is.na(response), NA, response %in% c(3))
    ) %>%
    select(-response) %>%
    pivot_longer(
      c(understands, produces),
      names_to = "type",
      values_to = "response"
    ) %>%
    drop_na(response) %>%
    left_join(select_at(pool, vars("item", "te", "language", any_of(by)))) %>%
    left_join(select_at(logs, vars("id", any_of(by)))) %>%
    mutate(item_dominance = ifelse(language==dominance, "L1", "L2")) %>%
    select_at(c("id", "time", "age", "item_dominance", "type", "te", "item", by, "response"))

  # total vocabulary
  vocab_total <- vocab_base %>%
    group_by_at(c("id", "time", "age", "type", by)) %>%
    summarise(
      vocab_count_total = sum(response, na.rm = TRUE),
      vocab_n_total = n(),
      .groups = "drop"
    ) %>%
    mutate(vocab_prop_total = ifelse(vocab_n_total==0, 0, vocab_count_total/vocab_n_total))

  # total vocabulary in Catalan
  vocab_total_dominance <- vocab_base %>%
    group_by_at(c("id", "time", "age", "type", "item_dominance", by)) %>%
    summarise(
      vocab_count_dominance = sum(response, na.rm = TRUE),
      vocab_n_dominance = sum(!is.na(response)),
      .groups = "drop"
    ) %>%
    mutate(vocab_prop_dominance = ifelse(vocab_n_dominance==0, 0, vocab_count_dominance/vocab_n_dominance)) %>%
    pivot_wider(names_from = item_dominance, values_from = matches("vocab")) %>%
    clean_names()

  # conceptual vocabulary
  vocab_conceptual <- vocab_base %>%
    group_by_at(c("id", "time", "age", "type", "te", by)) %>%
    summarise(
      vocab_count_conceptual = any(response),
      vocab_count_te = (n()>1) & all(response),
      .groups = "drop"
    ) %>%
    group_by_at(c("id", "time", "age", "type", by)) %>%
    summarise(
      vocab_count_conceptual = sum(vocab_count_conceptual, na.rm = TRUE),
      vocab_n_conceptual = n(),
      vocab_count_te = sum(vocab_count_te, na.rm = TRUE),
      vocab_n_te = n(),
      .groups = "drop"
    ) %>%
    mutate(
      vocab_prop_conceptual = ifelse(vocab_n_conceptual==0, 0, vocab_count_conceptual/vocab_n_conceptual),
      vocab_prop_te = ifelse(vocab_n_te==0, 0, vocab_count_te/vocab_n_te)
    )

  # merge all datasets
  vocab <- reduce(
    list(
      vocab_total,
      vocab_total_dominance,
      vocab_conceptual
    ),
    left_join,
    by = c("id", "time", "age", "type", by)
  ) %>%
  select_at(vars("id", "time", "age", "type", by, matches(scale)))

  return(vocab)

}
