# ml_vocabulary

#' Generate participant information and progress for each response
#' @export ml_vocabulary
#' @import dplyr
#' @importFrom tidyr pivot_longer
#' @importFrom tidyr drop_na
#' @importFrom tidyr pivot_wider
#' @importFrom purrr reduce
#' @importFrom janitor clean_names
#' @importFrom rlang .data
#' @param participants Participants data frame, as generated by \code{ml_participants}. If NULL (default), \code{ml_participants} is run.
#' @param responses Responses data frame, as generated by \code{ml_responses}. If NULL (default), \code{ml_responses} is run.
#' @param by A character vector that takes the name of the variable(s) to group data into. Vocabulary metrics will be calculated by aggregating responses within the groups that result from the combination of crossing of the variables provided in \code{by}. This variables can refer to item properties (see \code{pool}, e.g., "category") or to participant properties (see \code{ml_logs()}, e.g., "dominance").
#' @param scale A character vector that takes the value "count" and/or "prop". If "count" (default) vocabulary metrics are reported as counts (number of words). If "prop", vocabulary metrics are calculated as proportions?
#' @return A dataset with each participant's comprehensive and/or vocabulary size in each language
#'
ml_vocabulary <- function(
  participants = NULL,
  responses = NULL,
  by = NULL,
  scale = "count"
) {

  suppressMessages({

    ml_connect() # get credentials to Google and formr

    if (!any(scale %in% c("count", "prop"))) {
      stop("Argument scale must be 'count' and/or 'prop'")
    }

    if (is.null(responses)) {
      if (is.null(participants)) {
        participants <- ml_participants()
      }
      responses <- ml_responses()
    }

    logs <- ml_logs(participants, responses) %>%
      filter(.data$id %in% unique(responses$id)) # get logs

    vocab_base <- responses %>%
      mutate(
        understands = ifelse(is.na(.data$response), NA, .data$response %in% c(2, 3)),
        produces = ifelse(is.na(.data$response), NA, .data$response %in% c(3))
      ) %>%
      select(-.data$response) %>%
      pivot_longer(
        c(.data$understands, .data$produces),
        names_to = "type",
        values_to = "response"
      ) %>%
      drop_na(.data$response) %>%
      left_join(select_at(pool, vars("item", "te", "language", any_of(by)))) %>%
      left_join(select_at(logs, vars("id", "time", any_of(by)))) %>%
      mutate(item_dominance = ifelse(.data$language==.data$dominance, "L1", "L2")) %>%
      select_at(c("id", "time", "age", "item_dominance", "type", "te", "item", by, "response"))

    # total vocabulary
    vocab_total <- vocab_base %>%
      group_by_at(c("id", "time", "age", "type", by)) %>%
      summarise(
        vocab_count_total = sum(.data$response, na.rm = TRUE),
        vocab_n_total = n(),
        .groups = "drop"
      ) %>%
      mutate(vocab_prop_total = ifelse(.data$vocab_n_total==0, 0, .data$vocab_count_total/.data$vocab_n_total))

    # total vocabulary in Catalan
    vocab_total_dominance <- vocab_base %>%
      group_by_at(c("id", "time", "age", "type", "item_dominance", by), .drop = FALSE) %>%
      summarise(
        vocab_count_dominance = sum(.data$response, na.rm = TRUE),
        n_total = sum(!is.na(.data$response)),
        .groups = "drop"
      ) %>%
      mutate(vocab_prop_dominance = ifelse(.data$n_total==0, 0, .data$vocab_count_dominance/.data$n_total)) %>%
      pivot_wider(names_from = .data$item_dominance, values_from = c(n_total, matches("vocab"))) %>%
      clean_names() %>%
      select(id, time, age, type, starts_with("vocab_count"), starts_with("vocab_prop"))

    # conceptual vocabulary
    vocab_conceptual <- vocab_base %>%
      group_by(id, age, time) %>%
      mutate(n_total = length(unique(.data$te))) %>%
      ungroup() %>%
      filter(response) %>%
      count(id, time, age, type, te, n_total, .drop = FALSE) %>%
      count(id, time, age, type, n_total, .drop = FALSE) %>%
      rename(vocab_count_conceptual = n) %>%
      mutate(
        vocab_count_conceptual = as.integer(vocab_count_conceptual),
        vocab_prop_conceptual = .data$vocab_count_conceptual/.data$n_total
      ) %>%
      select(id, time, age, type, vocab_count_conceptual, vocab_prop_conceptual)

    # TE vocabulary
    vocab_te <- vocab_base %>%
      group_by(id, time, age) %>%
      mutate(n_total = length(unique(.data$te))) %>%
      ungroup() %>%
      filter(response) %>%
      count(id, time, age, type, te, n_total, .drop = FALSE) %>%
      filter(n > 1) %>%
      count(id, time, age, type, n_total, .drop = FALSE) %>%
      rename(vocab_count_te = n) %>%
      mutate(
        vocab_prop_te = .data$vocab_count_te/.data$n_total,
        vocab_count_te = as.integer(vocab_count_te)
      ) %>%
      select(id, time, age, type, vocab_count_te, vocab_prop_te)

    # merge all datasets
    vocab <- reduce(
      list(
        vocab_total,
        vocab_total_dominance,
        vocab_conceptual,
        vocab_te
      ),
      left_join,
      by = c("id", "time", "age", "type", by)
    ) %>%
      mutate_at(vars(matches("conceptual|te")), function(x) ifelse(is.na(x), as.integer(0), x)) %>%
      select_at(vars(one_of("id", "time", "age", "type", by), matches(scale))) %>%
      arrange(desc(id), time, type)

  })
  return(vocab)

}

